{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"children":[{"parent":"root","children":[{"parent":"f484f99a9144","children":[],"id":"32006bdfef13","title":"Runloop用来实现事件循环机制，也就是线程可以随时响应并处理事件"},{"parent":"f484f99a9144","children":[],"id":"130e145ecaf8","title":"可以让APP能够持续响应，保证程序运行状态"},{"parent":"f484f99a9144","children":[],"id":"04ee4ca3c1d1","title":"实现事件循环机制的核心是：如何让线程在没有消息处理时休眠，有消息到来时立刻被唤醒、"}],"collapsed":false,"id":"f484f99a9144","title":"简介"},{"parent":"root","children":[{"parent":"39415037fe75","children":[],"id":"e75176036a77","title":"保持程序持续运行"},{"parent":"39415037fe75","children":[{"parent":"4b1a5204d393","children":[],"id":"27350d6239f7","title":"定时器（Timer）、方法调用（PerFormSelecotr）"},{"parent":"4b1a5204d393","children":[],"id":"dedad5663793","title":"GCD Async Main Queue"},{"parent":"4b1a5204d393","children":[],"id":"6439eaa640de","title":"事件响应、手势识别、界面刷新"},{"parent":"4b1a5204d393","children":[],"id":"a6bba87fb871","title":"网络请求"},{"parent":"4b1a5204d393","children":[],"id":"314d29a2ffee","title":"自动释放池autoreleasePool"}],"id":"4b1a5204d393","title":"响应事件"},{"parent":"39415037fe75","children":[{"parent":"234fbd0fb2c0","children":[{"parent":"cdaecbd708d4","children":[],"id":"2d80af896422","title":"这个才是重点，指导文档中指明的作用，也是Runloop的核心"}],"style":{"color":"#f15a23"},"id":"cdaecbd708d4","title":"线程在没有消息处理时休眠，有消息到来时立刻被唤醒"}],"id":"234fbd0fb2c0","title":"节省CPU资源，提高程序性能"}],"collapsed":false,"id":"39415037fe75","title":"作用"},{"parent":"root","children":[{"parent":"7df2a3c3b279","children":[],"id":"4f4bf927cb1d","title":"RunLoop是为了给线程使用的，也可以说RunLoop就是基于线程来管理的"},{"parent":"7df2a3c3b279","children":[],"id":"2c346312f6f1","title":"所以我们可以看到在官方文档中，Runloop是在NSThread文档中介绍的"},{"parent":"7df2a3c3b279","children":[],"id":"c50ce9044a4a","title":"每个线程如果需要持续运行或响应事件，就需要加一个RunLoop"},{"parent":"7df2a3c3b279","children":[{"parent":"ccbdebc1e657","children":[],"id":"ea173f5ea881","title":"RunLoop不会手动创建，只能获取"},{"parent":"ccbdebc1e657","children":[],"id":"3a6d1974f82a","title":"主线程所对应的RunLoop是在程序启动时创建主线程的时候系统创建的"},{"parent":"ccbdebc1e657","children":[],"id":"abf078ec616f","title":"子线程对应的RunLoop并不是在子线程创建的时候创建的，而是在第一次获取RunLoop的时候创建的"},{"parent":"ccbdebc1e657","children":[],"id":"c736d58a8ad5","title":"如果子线程不使用RunLoop，也就不会创建，也就是说主线程肯定会有RunLoop，子线程不一定会用到"}],"id":"ccbdebc1e657","title":"RunLoop的创建"},{"parent":"7df2a3c3b279","children":[{"parent":"0e8cd4d3a031","children":[],"id":"1db9c4e87a1d","title":"底层是通过在runLoopDic中，通过线程Key来获取RunLoop的value"}],"id":"0e8cd4d3a031","title":"RunLoop的获取"},{"parent":"7df2a3c3b279","children":[{"parent":"ae6031117c7f","children":[],"id":"54111646909a","title":"线程结束时，RunLoop会自动销毁"},{"parent":"ae6031117c7f","children":[],"id":"af87c52a5b2d","title":"注意：我们不能手动销毁RunLoop"}],"id":"ae6031117c7f","title":"RunLoop的销毁"}],"collapsed":false,"id":"7df2a3c3b279","title":"RunLoop与线程"},{"parent":"root","children":[{"parent":"e166d071c844","children":[{"parent":"842fac340cf0","children":[],"id":"3277690f32d9","title":"Foundation框架中的，提供了面向对象的API"},{"parent":"842fac340cf0","children":[],"id":"f45b9e4b84ad","title":"NSRunloop是基于CFRunloopRef的"},{"parent":"842fac340cf0","children":[],"id":"b9cba80074e6","title":"API不是安全的"},{"parent":"842fac340cf0","children":[{"parent":"63f2240c2a1c","children":[],"id":"873173b5c162","title":"[NSRunloop currentRunloop]"},{"parent":"63f2240c2a1c","children":[],"id":"9374956690f1","title":"[NSRunloop mainRunloop]"}],"id":"63f2240c2a1c","title":"获取Runloop"}],"id":"842fac340cf0","title":"NSRunloop对象"},{"parent":"e166d071c844","children":[{"parent":"76833638fbdd","children":[{"parent":"5d20b7c20a02","image":{"w":565,"h":290,"url":"http://cdn2.processon.com/5fa7aff2e4b045e43cdd4b86?e=1604828675&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:PSs3fW7nNFTRSWIrgOmuebXvuVY="},"children":[],"id":"b79f137caa38","title":"子主题"}],"id":"5d20b7c20a02","title":"图示"},{"parent":"76833638fbdd","children":[{"parent":"f5957e29acaa","children":[],"id":"18d74a1317e1","title":"NSRunloop的底层就是CFRuNLoopRef"}],"id":"f5957e29acaa","title":"CFRunloopRef"},{"parent":"76833638fbdd","children":[{"parent":"b3aa8ba5a530","children":[],"id":"877c719b7540","title":"是NSRunloop的运行模式，每个RunLoop都可以有多种模式，每次只能用一种"}],"id":"b3aa8ba5a530","title":"NSRunLoopModeRef"},{"parent":"76833638fbdd","children":[{"parent":"73a8e438b57f","children":[],"id":"d69af5419034","title":"响应事件源"}],"id":"73a8e438b57f","title":"NSRunLoopSourceRef"},{"parent":"76833638fbdd","children":[{"parent":"b7e0f3f68ce0","children":[],"id":"fd20d60edc67","title":"响应时间源，NSTimer"}],"id":"b7e0f3f68ce0","title":"NSRunLoopTimerRef"},{"parent":"76833638fbdd","children":[{"parent":"dd2330f5f8a7","children":[],"id":"d11f534a9b81","title":"监听RunLoop运行状态"}],"id":"dd2330f5f8a7","title":"NSRunLoopObserverRef"}],"id":"76833638fbdd","title":"NSRunloop对象的相关类"},{"parent":"e166d071c844","children":[{"parent":"119b8d57d4d2","note":"struct __CFRunLoop {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\n    __CFPort _wakeUpPort;   //通过该函数CFRunLoopWakeUp内核向该端口发送消息可以唤醒runloop\n    Boolean _unused;\n    volatile _per_run_data *_perRunData;            \n    pthread_t _pthread;//RunLoop对应的线程\n    uint32_t _winthread;\n    CFMutableSetRef _commonModes;//存储的是字符串，记录所有标记为common的mode\n    CFMutableSetRef _commonModeItems;//存储所有commonMode的item(source、timer、observer)\n    CFRunLoopModeRef _currentMode;//当前运行的mode\n    CFMutableSetRef _modes;//存储的是CFRunLoopModeRef\n    struct _block_item *_blocks_head;//do blocks的时候用到\n    struct _block_item *_blocks_tail;\n    CFAbsoluteTime _runTime;\n    CFAbsoluteTime _sleepTime;\n    CFTypeRef _counterpart;\n};\n","children":[{"parent":"944f5e4be77d","children":[],"id":"2b912555653b","title":"是CoreFoundation框架中的，纯C函数的API"},{"parent":"944f5e4be77d","children":[],"id":"24d067ff05ac","title":"API是线程安全的"},{"parent":"944f5e4be77d","children":[{"parent":"60cfa1408b7b","children":[],"id":"b60eaeac0b3e","title":"CFRunloopGetCurrent()"},{"parent":"60cfa1408b7b","children":[],"id":"45fc8124e7d1","title":"CFRunlolopGetMain()"}],"id":"60cfa1408b7b","title":"获取Runloop的方法"}],"id":"944f5e4be77d","title":"CFRunloopRef对象"}],"id":"119b8d57d4d2","title":"CFRunloopRef对象的认识"},{"parent":"e166d071c844","children":[{"parent":"e02af2210d42","children":[{"parent":"4df3a1fb8f83","children":[],"id":"e6f03ad50067","title":"是RunLoop的运行模式，通过名称来识别"}],"id":"4df3a1fb8f83","title":"介绍"},{"parent":"e02af2210d42","children":[{"parent":"ad89df3c1131","children":[{"parent":"f80d1ec0bc90","children":[],"id":"09f77e37ec37","title":"APP默认的Mode，主线程的RunLoop就是在这个Mode下运行"}],"id":"f80d1ec0bc90","title":"kCFRunLoopDefaultMode"},{"parent":"ad89df3c1131","children":[{"parent":"7b37767f1362","children":[],"id":"a85d92a7385d","title":"界面跟踪Mode，用于追踪触摸滑动，保证界面滑动不受其他Mode影响"}],"id":"7b37767f1362","title":"UITrackingRunLoopMode"},{"parent":"ad89df3c1131","children":[{"parent":"e38c2754fab8","children":[],"id":"55643f7bc164","title":"初始化Mode，在刚启动APP时首先会进入，启动完成会自动切换为默认Mode"}],"id":"e38c2754fab8","title":"UIInitializationRunLoopMode"},{"parent":"ad89df3c1131","children":[{"parent":"956cabc75550","children":[],"id":"7789545aaedc","title":"接收系统事件的内部Mode，基本用不到"}],"id":"956cabc75550","title":"GSEventReceiveRunLoopMode"},{"parent":"ad89df3c1131","children":[{"parent":"3ea160a218ec","children":[],"id":"80d107848c01","title":"公共Mode"}],"id":"3ea160a218ec","title":"kCFRunLoopCommonModes"}],"id":"ad89df3c1131","title":"系统默认的Mode"},{"parent":"e02af2210d42","children":[{"parent":"66c4d9c5199b","children":[],"id":"4bd24c930d38","title":"在RunLoop对象中有_commonModes和_commonModeItems两个字段"},{"parent":"66c4d9c5199b","children":[],"id":"876cbee7820e","title":"表示为通用的Mode，commonModeItems的内容会自动同步到所有标记为common的Mode"},{"parent":"66c4d9c5199b","children":[],"id":"cfc2ca14156b","title":"在_commonModeItmes中添加的是Source/Timer/Observer"},{"parent":"66c4d9c5199b","children":[{"parent":"98478a5d465d","children":[],"id":"44db1fa09868","title":"CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);"}],"collapsed":false,"id":"98478a5d465d","title":"标记一个mode为Common"},{"parent":"66c4d9c5199b","children":[{"parent":"6ea8264c6527","children":[],"id":"f0759fa81a88","title":"[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];"}],"id":"6ea8264c6527","title":"标记一个ModeItem为Common"}],"id":"66c4d9c5199b","title":"CommonModes认识"},{"parent":"e02af2210d42","children":[{"parent":"6e13cfe2a5ce","children":[],"id":"71cbc67f0f29","title":"对于一个RunLoop，其内部的Mode只能增加不能删除，因为很明显我们不能自动创建和删除Mode本身，只能添加"},{"parent":"6e13cfe2a5ce","children":[{"parent":"fc1fe6e7c8a2","children":[],"id":"099b960d63f9","title":"CFRunLoopRunInMode(CFStringRef modeName, ...);"}],"id":"fc1fe6e7c8a2","title":"设置某一个Mode给一个RunLoop"}],"id":"6e13cfe2a5ce","title":"管理Mode的接口"},{"parent":"e02af2210d42","children":[{"parent":"9d057a4e52c6","children":[{"parent":"af8985b7520c","children":[],"id":"ad7dce76b11f","title":"RunLoop需要处理的消息属于Mode Item，包括Timer以及Source"},{"parent":"af8985b7520c","children":[],"id":"44825cdbc85f","title":"RunLoop可以被别人监听，被监听的对象就是Observer，也属于Mode Item"}],"id":"af8985b7520c","title":"ModeItmes包括什么"},{"parent":"9d057a4e52c6","children":[{"parent":"aba838453607","children":[],"id":"8131e25d3691","title":"Mode Item可以添加到Mode中，"},{"parent":"aba838453607","children":[],"id":"b7c662b8d713","title":"一个Mode可以包含多个ModeItem"},{"parent":"aba838453607","children":[],"id":"c5ee03fbdfd8","title":"一个ModeItem也可以存在于多个Mode中"},{"parent":"aba838453607","children":[],"id":"dd8cebfad712","title":"如果一个ModeItem多次添加到一个Mode中，会被覆盖掉"}],"id":"aba838453607","title":"Mode与ModeItems的关系"},{"parent":"9d057a4e52c6","children":[{"parent":"4e465fb38615","children":[],"style":{"color":"#f15a23"},"id":"605ee6afe286","title":"一个Mode中没有Mode Item，RunLoop会直接退出，不进行循环"},{"parent":"4e465fb38615","children":[],"id":"313a51630496","title":"当给一个RunLoop传入一个Mode时，如果不存在，则系统会帮我们创建对应的CFRunLoopModeRef"}],"id":"4e465fb38615","title":"注意："},{"parent":"9d057a4e52c6","children":[{"parent":"81bf60188d74","children":[],"id":"76b020348499","title":"CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);<br>CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);<br>CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);<br>CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);<br>CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);<br>CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);<br>"}],"id":"81bf60188d74","title":"方法"}],"id":"9d057a4e52c6","title":"管理ModeItems的接口"},{"parent":"e02af2210d42","children":[{"parent":"ca227008c082","image":{"w":900,"h":414.91525423728814,"url":"http://cdn2.processon.com/5fa7b869e4b0db0225b99d03?e=1604830841&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:e7hUadlKvvcdBaIxKl5T30RuSNQ="},"children":[],"id":"2c1187a6dc22","title":"子主题"}],"id":"ca227008c082","title":"Mode的使用"}],"id":"e02af2210d42","title":"RunLoopModeRef"},{"parent":"e166d071c844","children":[{"parent":"d77c72ee690f","children":[{"parent":"66734da72851","children":[],"id":"beb36b25e3cf","title":"Source表示事件源，包含两种"}],"id":"66734da72851","title":"介绍"},{"parent":"d77c72ee690f","children":[{"parent":"7bc42867ed6b","children":[],"id":"49159b495a5f","title":"Source0用来实现触摸事件和performSelector方法调用的事件"},{"parent":"7bc42867ed6b","children":[],"id":"c38293c8274b","title":"Source0只包含一个回调函数，并不能主动触发事件，需要先设置为待处理，之后手动唤醒"}],"id":"7bc42867ed6b","title":"Source0"},{"parent":"d77c72ee690f","children":[{"parent":"932293da4354","children":[],"id":"eac38345dfb4","title":"Source1用来实现系统事件和基于Port的线程间通信"},{"parent":"932293da4354","children":[],"id":"114e23e8d4f4","title":"Source1除了一个回调函数，还有一个math_port，它可以用于通过内核来和其他线程通信"},{"parent":"932293da4354","children":[],"id":"54f3c5eb938a","title":"Source1可以主动触发事件"}],"id":"932293da4354","title":"Source1"}],"id":"d77c72ee690f","title":"RunLoopSourceRef"},{"parent":"e166d071c844","children":[{"parent":"32eca84ff273","children":[{"parent":"d7b35be496b1","children":[],"id":"e266f1ea7b35","title":"是基于时间的触发器，包含了一个时间长度和一个回调"},{"parent":"d7b35be496b1","children":[],"id":"a89abe0744ce","title":"当加入到RunLoop时，会注册相应的时间点，当时间点到时，RunLoop会主动被唤醒去执行回调操作"}],"id":"d7b35be496b1","title":"介绍"},{"parent":"32eca84ff273","children":[{"parent":"6ddb6a9f2cbe","children":[{"parent":"34b9023d0873","children":[],"id":"1e43f51e247f","title":"定时器"}],"id":"34b9023d0873","title":"NSTimer"},{"parent":"6ddb6a9f2cbe","children":[{"parent":"c733d79493a5","children":[],"id":"7d9dfff42a54","title":"这个方法表示延时多久后执行"}],"id":"c733d79493a5","title":"performSelector:withObject:afterDelay:"}],"id":"6ddb6a9f2cbe","title":"使用"}],"id":"32eca84ff273","title":"RunLoopTimersRef"},{"parent":"e166d071c844","children":[{"parent":"60097dd55d39","children":[{"parent":"ad4379410dc8","children":[],"id":"d743d48d9b61","title":"用来监听RunLoop本身的状态改变的，每个Observer都包含一个回调函数。当RunLoop的状态发生变化时，监听者就可以通过回调来接收到这个变化"}],"id":"ad4379410dc8","title":"介绍"},{"parent":"60097dd55d39","children":[{"parent":"69ef7734f43f","image":{"w":660,"h":271,"url":"http://cdn2.processon.com/5fa7baebe4b0876d41fd34ed?e=1604831483&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:nweMbSdiQ-Vn4uoshLR4fDbMxgc="},"children":[],"id":"08180006dba5","title":"子主题"}],"id":"69ef7734f43f","title":"观察时间点"},{"parent":"60097dd55d39","children":[{"parent":"a3b6f8e75aa4","image":{"w":900,"h":675.9757155247181,"url":"http://cdn2.processon.com/5fa7bb0ee4b0db0225b9a04f?e=1604831518&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:y2vYVxvFg5qRqUiNQma0RSj8sco="},"children":[],"id":"357978ea4ad5","title":"子主题"}],"collapsed":false,"id":"a3b6f8e75aa4","title":"使用"}],"id":"60097dd55d39","title":"RunLoopObserverRef"},{"parent":"e166d071c844","children":[{"parent":"8d611067b941","children":[],"id":"1ebf7ae9de69","title":"一个RunLoop包含若干个mode，每个mode又包含了多个Source/Timer/Oberver"},{"parent":"8d611067b941","children":[],"id":"fb579a13d9ed","title":"每次调用RunLoop，只能指定一个mode，这个mode我们可以通过currentMode来获取"},{"parent":"8d611067b941","children":[],"id":"c0e777bc8cb5","title":"每次切换mode需要先退出循环，再指定一个mode进入"},{"parent":"8d611067b941","children":[],"id":"c0a5fcedef94","title":"如果mode中部存在Source/Timer/Oberver，就会直接退出，不进入此循环"}],"style":{"color":"#f15a23"},"id":"8d611067b941","title":"注意："}],"collapsed":false,"id":"e166d071c844","title":"Runloop对象的认识"},{"parent":"root","children":[{"parent":"4f88713b97b6","children":[{"parent":"332b520843d3","image":{"w":862,"h":384,"url":"http://cdn2.processon.com/5fa7bcd4e4b045e43cdd636a?e=1604831972&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:zAEUSqM5zSEPUOJobfiqdhgKLSk="},"children":[],"id":"692210f9a56d","title":"子主题"}],"id":"332b520843d3","title":"示意图"},{"parent":"4f88713b97b6","children":[{"parent":"ec8da9ca2b3e","children":[{"parent":"ee18ec86bc44","children":[{"parent":"62ee96e4beee","children":[{"parent":"97ef711899c3","children":[],"id":"a33cf818289b","title":"基于内核的事件，一般是由内核自动发出信号"}],"id":"97ef711899c3","title":"Port-Based Sources"},{"parent":"62ee96e4beee","children":[{"parent":"8d04df0dfbdd","children":[],"id":"a5451b5e7e8b","title":"非内核事件，一般是用户手动创建Source，需要从其他线程手动发送信号"}],"id":"8d04df0dfbdd","title":"Custom Input Sources"},{"parent":"62ee96e4beee","children":[],"id":"2aabba2010ea","title":"performSelector系列方法，也是一种事件源，这里的方法不延迟执行"}],"id":"62ee96e4beee","title":"异步"},{"parent":"ee18ec86bc44","children":[{"parent":"fa4950beb254","children":[],"id":"9838a6ab01b0","title":"NSTimer"},{"parent":"fa4950beb254","children":[],"id":"99a0d71eb23d","title":"performSelector:withOject:afterDelay:"}],"id":"fa4950beb254","title":"同步"}],"id":"ee18ec86bc44","title":"同步异步分类"},{"parent":"ec8da9ca2b3e","children":[{"parent":"4f4a1a669f81","children":[{"parent":"e5c990579bf0","children":[],"id":"e1d67d79bdcd","title":"通过内核来和其他线程进行通信，接收、分发系统事件，大部分屏幕及哦啊胡事件由Source1接收，之后分发下去，最后由Source0来处理"},{"parent":"e5c990579bf0","children":[{"parent":"8578ceb9befd","children":[],"id":"0948f3770f2d","title":"基于Port的线程间通信"},{"parent":"8578ceb9befd","children":[],"id":"f76f242c9f93","title":"系统事件捕获"}],"id":"8578ceb9befd","title":"做触发的事情包括"}],"id":"e5c990579bf0","title":"Source1"},{"parent":"4f4a1a669f81","children":[{"parent":"cfd681926198","children":[],"id":"851af8158690","title":"非Port事件，与界面交互的触摸事件的最终处理"},{"parent":"cfd681926198","children":[],"id":"fbbffe0c3501","title":"performSelector处理（没有delay）"}],"id":"cfd681926198","title":"Source0"},{"parent":"4f4a1a669f81","children":[{"parent":"6f95a659cbc9","children":[],"id":"24b7749503c7","title":"NSTimer"},{"parent":"6f95a659cbc9","children":[],"id":"443b587e204c","title":"performSelector:withOject:afterDelay:"}],"id":"6f95a659cbc9","title":"Timers"}],"id":"4f4a1a669f81","title":"按对象分裂"}],"id":"ec8da9ca2b3e","title":"事件源的分类"},{"parent":"4f88713b97b6","children":[{"parent":"25b40a8d2c87","children":[{"parent":"7e17d6914a07","image":{"w":843,"h":627,"url":"http://cdn2.processon.com/5fa7dd56e4b0876d41fd6be3?e=1604840294&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:34DFx44mefqN5TmfrVQRM-1x-xo="},"children":[],"id":"d166c8cfc6bd","title":"子主题"}],"id":"7e17d6914a07","title":"示意图"}],"id":"25b40a8d2c87","title":"处理过程"}],"collapsed":false,"id":"4f88713b97b6","title":"RunLoop的实现逻辑"},{"parent":"root","children":[{"parent":"9adf81082044","children":[{"parent":"a0fd83d8f09b","children":[{"parent":"ce17ca62b1aa","children":[],"id":"81fb38e91ce5","title":"Source0用来实现触摸事件和performSelector方法调用的事件"},{"parent":"ce17ca62b1aa","children":[],"id":"2ba3589279cf","title":"Source0只包含一个回调函数，并不能主动触发事件，需要先设置为待处理，之后手动唤醒"}],"id":"ce17ca62b1aa","title":"Source0"},{"parent":"a0fd83d8f09b","children":[{"parent":"d351432d41f3","children":[],"id":"9b38de15e525","title":"Source1用来实现系统事件和基于Port的线程间通信"},{"parent":"d351432d41f3","children":[],"id":"d5cb63098406","title":"Source1除了一个回调函数，还有一个math_port，它可以用于通过内核来和其他线程通信"},{"parent":"d351432d41f3","children":[],"id":"42e9bacf54d6","title":"Source1可以主动触发事件"}],"id":"d351432d41f3","title":"Source1"}],"id":"a0fd83d8f09b","title":"Source0和Source1的区别"},{"parent":"9adf81082044","children":[{"parent":"f3371ba577f2","children":[],"id":"155d3e894488","title":"默认Mode和界面跟踪Mode系统已经帮我们标记为Common了"},{"parent":"f3371ba577f2","children":[{"parent":"51e08dbe1804","children":[],"id":"ddf881f2f993","title":"CFRunloopAddCommonMode(runloop,modeName)"}],"id":"51e08dbe1804","title":"通过将Mode名称添加到RunLoop的commonModes中将一个Mode标记为Common"}],"id":"f3371ba577f2","title":"将一个Mode标记为Common属性"},{"parent":"9adf81082044","children":[],"style":{"color":"#f15a23"},"id":"989de390cea8","title":"在传入一个新的Mode时，RunLoop会帮我们创建对应的CFRunloopModeRef，但是如果Mode没有Mode Items，就不进入循环"}],"collapsed":true,"id":"9adf81082044","title":"注意："},{"parent":"root","children":[{"parent":"ac568c4d102b","children":[{"parent":"81be1dc2670e","children":[],"id":"30948d287b0a","title":"常驻线程就是可以持续运行，主线程就是一个常驻线程"},{"parent":"81be1dc2670e","children":[],"id":"c6a1986da097","title":"只要给一个线程增加一个RunLoop，就可以成为常驻线程"}],"id":"81be1dc2670e","title":"常驻线程"},{"parent":"ac568c4d102b","children":[{"parent":"ab9cad677d24","children":[],"id":"22a7e1e993e8","title":"NSTimer就是基于RunLoop运行的，当被添加到RunLoop之后，等到时间点之后会自动唤醒RunLoop来触发事件"},{"parent":"ab9cad677d24","children":[{"parent":"b30845e25672","children":[],"id":"ea34a4ce5957","title":"当NSTimer添加到默认Mode上时，进行滑动，NSTimer就会停止。"},{"parent":"b30845e25672","children":[],"id":"2678b13f8034","title":"需要将其添加到CommonModes中"},{"parent":"b30845e25672","children":[{"parent":"f8de0b904a39","children":[],"id":"23515924b951","title":"这个可能一般人不会说"}],"style":{"background-color":"rgb(252, 245, 222)","color":"#f15a23"},"id":"f8de0b904a39","title":"还有一种方法是，在子线程中去处理Timer事件，之后再主线程中响应"}],"id":"b30845e25672","title":"滑动时失效"},{"parent":"ab9cad677d24","children":[{"parent":"caa811b96412","children":[],"id":"3d05e1c09e13","title":"NSTimer本身就有一个宽容度，也就是标记了当时间点到后，容许有多少最大误差"},{"parent":"caa811b96412","children":[],"id":"32258dad6429","title":"如果某个时间点被错过了，比如这个时间点正在执行一个其他任务，这个时间点的任务就不再会执行了"}],"id":"caa811b96412","title":"不准时"}],"id":"ab9cad677d24","title":"NSTimer"},{"parent":"ac568c4d102b","children":[{"parent":"eea4aa20f891","children":[],"id":"2ed4ed3b6a7a","title":"主线程中的RunLoop一直在运行，触发的事件回调、Timer回调，如果一直不释放就会造成内存泄漏"},{"parent":"eea4aa20f891","children":[],"id":"d4f1f05d0590","title":"因此在监听到即将进入RunLoop时，会创建自动释放池"},{"parent":"eea4aa20f891","children":[],"id":"493efd6ce099","title":"在监听到即将休眠或即将推出RunLoop时，会销毁自动释放池，也就是释放自动释放池的对象"}],"id":"eea4aa20f891","title":"AutoreleasePool"},{"parent":"ac568c4d102b","children":[{"parent":"7b3faa3d4a4f","children":[],"id":"79a1a33dc6b0","title":"触摸屏幕后先将屏幕表面的事件包装成Event，Event先告诉Source1(mach_port），Source唤醒RunLoop，然后将事件分发给Source0，然后由Source0来处理。"}],"id":"7b3faa3d4a4f","title":"事件响应"},{"parent":"ac568c4d102b","children":[{"parent":"ba17ec8db5dc","children":[],"id":"64d5a397114b","title":"当操作UI时，比如改变了Frame，会被标记为待处理"},{"parent":"ba17ec8db5dc","children":[],"id":"e531b50257c6","title":"之后监听到RunLoop即将进入休眠或即将退出RunLoop时，就去将所有的UIView/CALayer去执行，并更新界面"},{"parent":"ba17ec8db5dc","children":[],"id":"0b6d72059fb5","title":"因此为了避免卡顿，UI排版和绘制运算都尽可能放到后台，界面更新都放到主线程中执行，这个时候就在主线程中增加了一个监听，进入休眠或退出时进行回调操作"}],"id":"ba17ec8db5dc","title":"界面更新"}],"collapsed":false,"id":"ac568c4d102b","title":"具体使用"},{"parent":"root","children":[{"parent":"32231feb8cd2","children":[{"parent":"57baf70147f9","children":[],"id":"119946b4d719","title":"RunLoop用来实现事件循环机制，内部就是一个do while循环，可以让线程持续运行，并对事件做出响应，它可以实现在没有消息处理时，进入休眠状态，有消息需要响应时，可以唤醒。每个线程都有自己对应的RunLoop，主线程系统会默认创建一个RunLoop。"}],"id":"57baf70147f9","title":"什么是RunLoop"},{"parent":"32231feb8cd2","children":[{"parent":"d594db64430f","children":[],"id":"94be9987939a","title":"NSRunloop是基于CFRunloopRef的封装，提供的是面向对象的API，不是线程安全的。CFRunloopRef是在在底层提供了纯C函数的API，所以是线程安全的。（他们可以混合使用）"}],"id":"d594db64430f","title":"NSRunloop和CFRunloopRef"},{"parent":"32231feb8cd2","children":[{"parent":"536257787479","children":[],"id":"c78e96c07311","title":"常见有五种，默认Mode，主线程的RunLoop就是用的默认mode，界面跟踪Mode，可以保证界面滑动时不受其他操作影响，初始化Mode，刚启动APP会用到，启动完成就使用默认Mode，接收系统时间的内部Mode，一般用不到，CommonModes，可以看做是公共的mode"},{"parent":"536257787479","children":[],"id":"22d85abb34c5","title":"RunLoop有不同的运行模式，不同模式之间是没有联系的，而且RunLoop一次只能使用一个Mode，如果想要切换Mode，必须先停止循环再切换"}],"id":"536257787479","title":"RunLoop有哪些Mode"},{"parent":"32231feb8cd2","children":[{"parent":"3e33d659065b","children":[],"id":"cc9448a1a777","title":"RunLoop内部循环是一个do-while循环，在循环中会不停的有事件源传入，包括输入源和时间源，输入源又包括Source0，Source1，Source0事件传入后先标记为待处理，之后"}],"id":"3e33d659065b","title":"RunLoop的运行过程"},{"parent":"32231feb8cd2","children":[{"parent":"b32e61e7c59c","children":[],"id":"343e309c029c","title":"主线程的RunLoop系统会帮我们启动"},{"parent":"b32e61e7c59c","children":[],"id":"840dfcf4c80b","title":"子线程的RunLoop当我们在获取的时候自动创建并启动"}],"id":"b32e61e7c59c","title":"RunLoop如何启动"},{"parent":"32231feb8cd2","children":[{"parent":"70f3e8ed8031","children":[],"id":"1b413d944168","title":"不生效"},{"parent":"70f3e8ed8031","children":[],"id":"58eae00da333","title":"因为dispatch_after底层依赖一个Timer，而Timer是依赖RunLoop存在的，而子线程中没有RunLoop的话就不会生效"}],"id":"70f3e8ed8031","title":"dispatch_after方法在子线程中是否生效，原因是什么？"},{"parent":"32231feb8cd2","children":[{"parent":"585bc5129a3e","children":[],"id":"60d3777ad719","title":"RunLoop即将启动的时候创建自动释放池，运行过程中RunLoop监听到即将进入休眠的时候释放，并且再创建一个新的自动释放池。最后RunLoop退出的时候进行释放"}],"id":"585bc5129a3e","title":"自动释放池什么时候释放"},{"parent":"32231feb8cd2","children":[],"style":{"color":"#f15a23"},"id":"ca97d4799041","title":"怎么检测界面的卡顿"},{"parent":"32231feb8cd2","children":[{"parent":"71a6ba9e9c48","children":[],"id":"e2bd1d4428ba","title":"线程创建的时候都会有一个入口函数，不管有没有RunLoop，都可以执行这个函数里的事件"}],"id":"71a6ba9e9c48","title":"线程刚创建时并没有RunLoop，如果不主动获取，那么他一直不会有，如果一直不获取，那这个线程就不能处理事件了吗&nbsp;"},{"parent":"32231feb8cd2","children":[],"id":"6247f3b16ccf","title":"开发中如何使用RunLoop？什么应用场景？"},{"parent":"32231feb8cd2","children":[{"parent":"cd36272e3288","children":[],"id":"b96e20bbd7eb","title":"为当前线程开启一个RunLoop，通过获取当前当前线程的RunLoop，就可以创建了RunLoop，之后给RunLoop添加ModeItem，也就是有事件源，要不然RunLoop会退出，之后就启动RunLoop，这样这个线程就是常驻线程了"}],"id":"cd36272e3288","title":"怎么创建一个常驻线程"},{"parent":"32231feb8cd2","children":[{"parent":"c3cbb0e7c14e","children":[{"parent":"adf846e7f558","image":{"w":656,"h":341,"url":"http://cdn2.processon.com/5fa7abf0e4b0876d41fd1398?e=1604827648&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:0xHpO1JJzH7E43_Xx76FLKFTWFE="},"children":[],"id":"596f4dd556d8","title":"子主题"}],"id":"adf846e7f558","title":"代码"},{"parent":"c3cbb0e7c14e","children":[{"parent":"561d046eb2b0","children":[],"id":"2f5146e0ae68","title":"输出结果是1423"},{"parent":"561d046eb2b0","children":[],"id":"6561742de4ae","title":"因为2和3是在子线程中，所以会先输出1和4，在子线程中先执行2，而test方法的执行中使用到了afterDelay进行延时操作，会在内部创建一个NSTimer，然后添加到当前线程的RunLoop中。而当前线程并没有开启RunLoop，所以该方法会失效。test方法并不会执行，所以顺序输出2和3"},{"parent":"561d046eb2b0","children":[],"id":"87d0b3be9349","title":"在调用方法之后应该启动RunLoop，[[NSRunLoop currentRunLoop] run];"}],"id":"561d046eb2b0","title":"答案"},{"parent":"c3cbb0e7c14e","children":[{"parent":"1b32cbbd564f","children":[],"style":{"color":"#f15a23"},"id":"6d36d906e5ae","title":"这里可能还会有一个考题，是启动RunLoop的顺序，如果使用run方法启动了RunLoop，但并没有设置Item，则会直接退出循环，应该是在设置Item之后再调用run"}],"id":"1b32cbbd564f","title":"注意"}],"id":"c3cbb0e7c14e","title":"输出下面代码的执行顺序"},{"parent":"32231feb8cd2","children":[{"parent":"4257cb5b8350","children":[],"id":"6f11d8029a98","title":"我们在子线程进行数据请求后，切回到主线程进行更新UI，如果此时正在界面，那么就会影响当前正在滑动的体验"},{"parent":"4257cb5b8350","children":[],"id":"95e113ee7574","title":"滑动界面时RunLoop的Mode是界面跟踪Mode，我们可以把更新UI事件放到默认Mode上执行，这样会等到Mode切换成默认Mode，才会去更新，也就不会影响界面滑动的体验了"},{"parent":"4257cb5b8350","children":[],"id":"d66d449d579c","title":"[self performSelectorOnMainThread:@selector(reloadData) withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];<br>"}],"id":"4257cb5b8350","title":"怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作"},{"parent":"32231feb8cd2","children":[{"parent":"2ae9ae221216","children":[],"id":"5aae2bbe23e1","title":"首先RunLoop是一个do...while循环"},{"parent":"2ae9ae221216","children":[],"id":"2be05688d918","title":"RunLoop的目的就是保证线程在没有消息时休眠，有消息是唤醒，可以提高性能"}],"id":"2ae9ae221216","title":"RunLoop的实现原理是什么"},{"parent":"32231feb8cd2","children":[{"parent":"28228fa33f88","children":[],"id":"815e26aaaf27","title":"RunLoop与线程是一对一关系，RunLoop是基于线程存在的，程序启动时，主线程默认会自己创建并启动一个RunLoop，创建子线程的时候，当我们获取RunLoop时，系统会帮我们创建RunLoop，并且需要手动run启动"}],"id":"28228fa33f88","title":"RunLoop和线程有什么关系"},{"parent":"32231feb8cd2","children":[{"parent":"55f5ac635588","children":[],"id":"df01b39e0fc9","title":"NSTimer就是基于RunLoop运行的，当被添加到RunLoop之后，等到时间点之后会自动唤醒RunLoop来触发事件"},{"parent":"55f5ac635588","children":[],"id":"3efbb9b4eef6","title":"NSTimer是RunLoop的时间源的一种"}],"id":"55f5ac635588","title":"NSTimer和RunLoop的关系"},{"parent":"32231feb8cd2","children":[{"parent":"0a19f035cd6d","children":[],"id":"ee104cf07e6b","title":"不准确"},{"parent":"0a19f035cd6d","children":[],"id":"06e0ea6944e6","title":"NSTimer本身就有一个宽容度，也就是标记了当时间点到后，容许有多少最大误差"},{"parent":"0a19f035cd6d","children":[],"id":"ab05833f7342","title":"如果某个时间点被错过了，比如这个时间点正在执行一个其他任务，这个时间点的任务就不再会执行了"},{"parent":"0a19f035cd6d","children":[],"id":"809f296edd65","title":"使用GCDTimer作为定时器，它是基于硬件事件，会更准确"}],"id":"0a19f035cd6d","title":"NSTimer准确吗，如果不准确，为什么，如何设计一个准确的Timer"},{"parent":"32231feb8cd2","children":[{"parent":"01d23c018e66","children":[],"id":"55ea73284818","title":"一个RunLoop不能同时存在多个Mode，而在界面滑动时，使用的是界面跟踪Mode，而NSTimer默认添加在defaultMode上，就会停止执行"},{"parent":"01d23c018e66","children":[],"id":"35ac43b33dba","title":"可以添加到界面跟踪Mode上，或者CommonModes上"}],"id":"01d23c018e66","title":"TableView/ScrollView/CollectionView滚动时为什么NSTimer会停止？"},{"parent":"32231feb8cd2","children":[{"parent":"56e9ab85f2ab","children":[],"id":"a5ce27cdfbdd","title":"NSTimer不会执行，没有启动"},{"parent":"56e9ab85f2ab","children":[],"id":"3b5150af9790","title":"因为NSTimer是基于RunLoop的，而子线程的RunLoop默认并没有创建和启动，所以无法执行"},{"parent":"56e9ab85f2ab","children":[],"id":"dcd739f8d8a9","title":"可以获取当前子线程的RunLoop并启动"}],"id":"56e9ab85f2ab","title":"如果NSTimer在子线程中创建，会发生什么，应该注意什么？"},{"parent":"32231feb8cd2","children":[{"parent":"1e4deeaaade0","children":[],"id":"2a125a54fec6","title":"可以在异步线程中启动一个RunLoop进行发送网络请求，这样他会一直不停的下载，直到下载全部完成"}],"id":"1e4deeaaade0","title":"在异步线程中下载很多图片,如果失败了,该如何处理?请结合RunLoop来谈谈解决方案"},{"parent":"32231feb8cd2","children":[{"parent":"0096a3a28cbe","children":[],"id":"b27307100dd7","title":"开启一个异步的子线程去执行该耗时操作，而且需要启动它的RunLoop，因为这样他就会一直执行下去，"}],"id":"0096a3a28cbe","title":"如果程序启动就需要执行一个耗时操作，你会怎么做？"},{"parent":"32231feb8cd2","children":[{"parent":"290716f80613","children":[],"id":"68a42f3aabaa","title":"RunLoop会使用autorelease释放自己的内存"},{"parent":"290716f80613","children":[],"id":"656f247d50e7","title":"RunLoop即将启动的时候创建自动释放池，运行过程中RunLoop监听到即将进入休眠的时候释放，并且再创建一个新的自动释放池。最后RunLoop退出的时候进行释放"}],"id":"290716f80613","title":"RunLoop与autoreleasePool的关系"},{"parent":"32231feb8cd2","children":[{"parent":"58044851e0fc","children":[],"id":"84b9ff113608","title":"问题：会出现这种情况，就是异步请求还未完成，子线程就已结束"},{"parent":"58044851e0fc","children":[],"id":"ee72732ce468","title":"子线程启动一个RunLoop，当请求未结束时就保持线程一直启动，直接结束"},{"parent":"58044851e0fc","children":[],"id":"70366301045d","title":"while(!isFinish)<br>     {<br>       [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];<br>     }<br>"}],"id":"58044851e0fc","title":"如果在子线程中又启动一个异步请求，会有什么问题？怎么解决"},{"parent":"32231feb8cd2","children":[{"parent":"c1e9828eeb7e","children":[],"id":"c02b6ea65097","title":"程序启动时，系统默认创建并启动主线程的RunLoop，并且使用的是默认Mode"},{"parent":"c1e9828eeb7e","children":[],"id":"607056acae46","title":"并且会默认创建两个Observe来监听RunLoop的进出和睡眠，有事情的时候就去做，没有事情就休眠"},{"parent":"c1e9828eeb7e","children":[],"id":"cf72c0e9552a","title":"并且还会创建一个自动释放池，之后在休眠时释放内存并创建新的自动释放池"},{"parent":"c1e9828eeb7e","children":[],"id":"57362a9e41fb","title":"会创建一个子线程，将耗时操作放到入子线程中执行，如果时间很长，也可以启动RunLoop"}],"id":"c1e9828eeb7e","title":"程序启动时，runloop是如何工作的？如果程序启动就需要执行一个耗时操作，你会怎么做？"},{"parent":"32231feb8cd2","children":[{"parent":"602a0ebd2d70","children":[],"id":"fe97e5a9d05e","title":"当调用performSelecter:afterDelay: 后，实际上起内部会创建一个Timer，并添加到当前线程的RunLoop中，所以如果没有RunLoop，这个方法就会失效"},{"parent":"602a0ebd2d70","children":[],"id":"8df897a6cdcd","title":"当调用performSelector:onThread:时，实际上会创建一个Timer到对应的线程中，同样的，如果对应线程没有RunLoop，该方法也会失效"}],"id":"602a0ebd2d70","title":"PerformSelector 的实现原理？"},{"parent":"32231feb8cd2","children":[{"parent":"4f6be247e42a","children":[],"id":"af083387ba76","title":"NSRunloop是基于CFRunloopRef的"},{"parent":"4f6be247e42a","children":[],"id":"ab1e28cd7eca","title":"他包含了各种Mode，和CommonMode，还有自己对应的线程，以及其他的一些东西"}],"id":"4f6be247e42a","title":"RunLoop的数据结构"},{"parent":"32231feb8cd2","children":[{"parent":"91b4276b3bcb","children":[],"id":"9e4543732d17","title":"Observer是ModeItem的一种，用来监听RunLoop的状态"},{"parent":"91b4276b3bcb","children":[],"id":"40c4c5c5c985","title":"比如有即将进入RunLoop，即将处理处理时间源Timer，即将处理事件源Source，即将休眠，刚从休眠中唤醒，即将推出RunLoop"}],"id":"91b4276b3bcb","title":"讲一下Observer"},{"parent":"32231feb8cd2","children":[{"parent":"968e4f53c1fd","children":[],"id":"bd8b86aeed65","title":"本质就是CFRunloopTimerRef，"}],"id":"968e4f53c1fd","title":"解释一下NSTimer"},{"parent":"32231feb8cd2","children":[],"id":"3cbf3b0dad88","title":"解释一下事件响应的过程"},{"parent":"32231feb8cd2","children":[],"id":"143f322310d1","title":"解释一下手势识别的过程"},{"parent":"32231feb8cd2","children":[],"id":"2f932d9d22c2","title":"什么是异步绘制"},{"parent":"32231feb8cd2","children":[],"id":"22b6d133993c","title":"利用RunLoop解释一下页面渲染的过程"},{"parent":"32231feb8cd2","children":[{"parent":"baba512d69b9","children":[{"parent":"43d774216d4e","children":[],"id":"a19375708ba6","title":"后面把所有的优先级都看下"},{"parent":"43d774216d4e","children":[],"id":"95f730d33a5c","title":"跑代码看"}],"id":"43d774216d4e","title":"是最低的"}],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"baba512d69b9","title":"定制器事件的优先级是咋样的"}],"collapsed":false,"id":"32231feb8cd2","title":"面试题"},{"parent":"root","children":[{"parent":"b85d20560dbb","children":[],"link":{"type":"url","title":"iOS底层开源代码","value":"https://opensource.apple.com/"},"id":"c586eaeee05c","title":"Darwin，操作系统的核心，底层开源代码"},{"parent":"b85d20560dbb","children":[],"link":{"type":"url","title":"","value":"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/InputControl/InputControl.html#//apple_ref/doc/uid/10000062i"},"id":"0e74a6b9bc85","title":"RunLoop官网"},{"parent":"b85d20560dbb","children":[],"link":{"type":"url","title":"","value":"https://www.jianshu.com/p/5ebe96acfe84"},"id":"116f0fe38f88","title":"RunLoop详细讲解"},{"parent":"b85d20560dbb","children":[],"link":{"type":"url","title":"","value":"https://blog.ibireme.com/2015/05/18/runloop/"},"id":"000223eea682","title":"大神的"},{"parent":"b85d20560dbb","children":[],"link":{"type":"url","title":"面试题","value":"https://www.jianshu.com/p/542b99dbaec8"},"id":"e9e5ef518ab2","title":"面试题"},{"parent":"b85d20560dbb","children":[],"link":{"type":"url","title":"","value":"https://www.jianshu.com/p/bfeb6fb0c057"},"id":"aaa729064e19","title":"面试题2，这里是详细讲解，可以查看他的多个博客，写了很多其他的面试题"},{"parent":"b85d20560dbb","children":[],"link":{"type":"url","title":"","value":"https://www.jianshu.com/p/ec629063390f"},"id":"a266d362a735","title":"讲解的比较详细，也值得一看"}],"collapsed":false,"id":"b85d20560dbb","title":"链接"}],"background":"#fcf5de","root":true,"theme":"paper","id":"root","title":"Runloop","structure":"mind_free"}},"meta":{"exportTime":"2021-01-09 20:04:46","member":"","diagramInfo":{"creator":"","created":"","modified":"","title":"","category":""},"id":"","type":"ProcessOn Schema File","version":"1.0"}}